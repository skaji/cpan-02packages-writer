#!/usr/bin/env perl
use v5.36;
use experimental qw(builtin defer for_list try);

use utf8;
use File::Find ();

binmode $_, ":utf8" for \*STDOUT, \*STDERR;

my $NAME = "cpan-02packages-writer";

my $USAGE = <<"EOF";
Usage: $NAME [directory]

Options:
 -h, --help  show this help

Examples:
❯ index-writer ./local > index.txt
EOF

my $HEADER = <<"EOF";
# This file is generated by https://github.com/skaji/$NAME
# You can use this file by:
#   cpm install --resolver 02packages,index.txt,https://cpan.metacpan.org Module
EOF

package App {
    sub new ($class) {
        bless { quiet => $ENV{QUIET} }, $class;
    }
    sub run ($self, $dir = undef, @) {
        die "need argument, try `$NAME --help`\n" if !$dir;
        die $USAGE if $dir =~ /^(-h|--help)$/n;
        die "$dir: no such direcotry\n" if !-d $dir;

        my @file;
        File::Find::find({
            wanted => sub () {
                my $name = $File::Find::name;
                push @file, $name if $name =~ /install\.json$/;
            },
            no_chdir => 1,
        }, $dir);
        die "couldn't find any install.json in $dir\n" if !@file;

        my $index = Index->new;
        for my $file (sort @file) {
            $self->info("loading $file");
            $index->add(Release->from_file($file));
        }
        print "$HEADER\n";
        print $index->to_string;
    }
    sub info ($self, @msg) {
        return if $self->{quiet};
        warn "---> @msg\n";
    }
}

package Index {
    sub new ($class) {
        bless { releases => [] }, $class;
    }
    sub add ($self, $release) {
        push $self->{releases}->@*, $release;
    }
    sub to_string ($self) {
        my %index;
        for my $release ($self->{releases}->@*) {
            for my ($package, $version) ($release->provides->%*) {
                $index{$package} = { version => $version, pathname => $release->pathname };
            }
        }
        my $out = "";
        for my $package (sort { lc $a cmp lc $b } keys %index) {
            my $version = $index{$package}{version} || "undef";
            my $pathname = $index{$package}{pathname};
            $out .= "$package $version $pathname\n";
        }
        $out;
    }
}

package Release {
    use JSON::PP ();
    my $JSON = JSON::PP->new;
    sub from_file ($class, $file) {
        open my $fh, "<:utf8", $file or die "$file: $!";
        my $c = $JSON->decode(do { local $/; <$fh> });
        my $name = $c->{dist};
        my $pathname = $c->{pathname};
        my %provide = map { ($_, $c->{provides}{$_}{version}) } sort keys $c->{provides}->%*;
        bless { name => $name, pathname => $pathname, provides => \%provide }, $class;
    }
    sub name ($self) {
        $self->{name};
    }
    sub pathname ($self) {
        $self->{pathname};
    }
    sub provides ($self) {
        $self->{provides};
    }
}

my $app = App->new;
$app->run(@ARGV);
